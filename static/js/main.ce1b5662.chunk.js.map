{"version":3,"sources":["components/TimeStamp.js","components/ChatEntry.js","components/ChatLog.js","App.js","registerServiceWorker.js","index.js"],"names":["TimeStamp","currentTimeStamp","time","DateTime","fromISO","absolute","toFormat","relative","toRelative","title","ChatEntry","id","sender","body","timeStamp","liked","onUpdateMessages","incrementCount","decreaseCount","entryTime","align","updatedEmoji","className","onClick","newMessage","propTypes","entries","PropTypes","arrayOf","shape","number","string","isRequired","bool","func","ChatLog","messageComponents","message","push","App","useState","chatMessages","messagesList","setMessageList","likesCount","setLikesCount","messageToUpdate","newMessageList","map","isLocalhost","Boolean","window","location","hostname","match","registerValidSW","swUrl","navigator","serviceWorker","register","then","registration","onupdatefound","installingWorker","installing","onstatechange","state","controller","console","log","catch","error","ReactDOM","render","document","getElementById","URL","process","origin","addEventListener","fetch","response","status","headers","get","indexOf","ready","unregister","reload","checkValidServiceWorker","registerServiceWorker"],"mappings":"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","file":"static/js/main.ce1b5662.chunk.js","sourcesContent":["import { DateTime } from 'luxon';\n\n// const TimeStamp = (props) => {\n//   const time = DateTime.fromISO(props.time);\nconst TimeStamp = (currentTimeStamp) => {\n  const time = DateTime.fromISO(currentTimeStamp);\n  const absolute = time.toFormat('MMMM Do YYYY, h:mm:ss a');\n  const relative = time.toRelative();\n\n  return <span title={absolute}>{relative}</span>;\n};\n\nexport default TimeStamp;\n","import React from 'react';\nimport PropTypes from 'prop-types';\n\nimport './ChatEntry.css';\nimport TimeStamp from './TimeStamp';\n\nconst ChatEntry = ({\n  id,\n  sender,\n  body,\n  timeStamp,\n  liked,\n  onUpdateMessages,\n  incrementCount,\n  decreaseCount,\n}) => {\n  const entryTime = TimeStamp(timeStamp);\n\n  let align = '';\n  if (id % 2 === 0) {\n    align = 'chat-entry remote';\n  } else {\n    align = 'chat-entry local';\n  }\n\n  const updateEmojiOnClick = () => {\n    const newMessage = {\n      id: id,\n      sender: sender,\n      body: body,\n      timeStamp: timeStamp,\n      liked: !liked,\n    };\n\n    if (newMessage.liked) {\n      incrementCount();\n    } else {\n      decreaseCount();\n    }\n\n    onUpdateMessages(newMessage);\n  };\n\n  const updatedEmoji = liked ? '‚ù§Ô∏è' : 'ü§ç';\n\n  return (\n    <div key={id} className={align}>\n      <h2 className=\"entry-name\">{sender}</h2>\n\n      <section className=\"entry-bubble\">\n        <p>{body}</p>\n\n        <p className=\"entry-time\">{entryTime}</p>\n\n        <button className=\"like\" onClick={updateEmojiOnClick}>\n          {updatedEmoji}\n        </button>\n      </section>\n    </div>\n  );\n};\n\nChatEntry.propTypes = {\n  id: PropTypes.number,\n  sender: PropTypes.string.isRequired,\n  body: PropTypes.string.isRequired,\n  timeStamp: PropTypes.string.isRequired,\n  liked: PropTypes.bool,\n  onUpdateMessages: PropTypes.func,\n  incrementCount: PropTypes.func,\n  decreaseCount: PropTypes.func,\n};\n\nexport default ChatEntry;\n","import React from 'react';\nimport PropTypes from 'prop-types';\n\nimport ChatEntry from './ChatEntry';\n\nconst ChatLog = ({\n  entries,\n  onUpdateMessages,\n  incrementCount,\n  decreaseCount,\n}) => {\n  const messageComponents = [];\n\n  for (const message of entries) {\n    messageComponents.push(\n      <ChatEntry\n        key={message.id}\n        id={message.id}\n        sender={message.sender}\n        body={message.body}\n        timeStamp={message.timeStamp}\n        liked={message.liked}\n        onUpdateMessages={onUpdateMessages}\n        incrementCount={incrementCount}\n        decreaseCount={decreaseCount}\n      />\n    );\n  }\n\n  return <div>{messageComponents}</div>;\n};\n\nChatEntry.propTypes = {\n  entries: PropTypes.arrayOf(\n    PropTypes.shape({\n      id: PropTypes.number,\n      sender: PropTypes.string.isRequired,\n      body: PropTypes.string.isRequired,\n      timeStamp: PropTypes.string.isRequired,\n      liked: PropTypes.bool,\n    })\n  ),\n  onUpdateMessages: PropTypes.func,\n  incrementCount: PropTypes.func,\n  decreaseCount: PropTypes.func,\n};\n\nexport default ChatLog;\n","import React from 'react';\nimport { useState } from 'react';\n\nimport './App.css';\nimport chatMessages from './data/messages.json';\nimport ChatLog from './components/ChatLog';\n\nconst App = () => {\n  const [messagesList, setMessageList] = useState(chatMessages);\n\n  const [likesCount, setLikesCount] = useState(0);\n\n  const updateMessages = (messageToUpdate) => {\n    const newMessageList = messagesList.map((message) => {\n      if (messageToUpdate.id === message.id) {\n        return messageToUpdate;\n      } else {\n        return message;\n      }\n    });\n    setMessageList(newMessageList);\n  };\n\n  function incrementCount() {\n    let currentCount = likesCount + 1;\n    setLikesCount(currentCount);\n  }\n\n  const decreaseCount = () => {\n    let currentCount = likesCount - 1;\n    setLikesCount(currentCount);\n  };\n\n  return (\n    <div id=\"App\">\n      <header>\n        {/* TODO: add names instead of hardcoding */}\n        <h1>Chat between Vladimir and Estragon</h1>\n        <section>\n          <div className=\"widget\" id=\"heartWidget\">\n            {likesCount} ‚ù§Ô∏ès{' '}\n          </div>\n        </section>\n      </header>\n      <main>\n        {/* Wave 01: Render one ChatEntry component */}\n        {/* <ChatEntry\n          body={testMessage.body}\n          sender={testMessage.sender}\n          timeStamp={testMessage.timeStamp}\n         /> */}\n\n        {/* Wave 02: Render ChatLog component  */}\n        <ChatLog\n          entries={messagesList}\n          onUpdateMessages={updateMessages}\n          incrementCount={incrementCount}\n          decreaseCount={decreaseCount}\n        />\n      </main>\n    </div>\n  );\n};\n\nexport default App;\n","// In production, we register a service worker to serve assets from local cache.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on the \"N+1\" visit to a page, since previously\n// cached resources are updated in the background.\n\n// To learn more about the benefits of this model, read https://goo.gl/KwvDNy.\n// This link also includes instructions on opting out of this behavior.\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport default function register() {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebookincubator/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Lets check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://goo.gl/SC7cgQ'\n          );\n        });\n      } else {\n        // Is not local host. Just register service worker\n        registerValidSW(swUrl);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the old content will have been purged and\n              // the fresh content will have been added to the cache.\n              // It's the perfect time to display a \"New content is\n              // available; please refresh.\" message in your web app.\n              console.log('New content is available; please refresh.');\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      if (\n        response.status === 404 ||\n        response.headers.get('content-type').indexOf('javascript') === -1\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport registerServiceWorker from './registerServiceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\nregisterServiceWorker();\n"],"sourceRoot":""}